\chapter{Análise do Problema}
\label{cap:analise}

O desafio deste projeto consiste na criação de uma linguagem de programação imperativa simples (LPIS) e respetivo compilador.
Para tal é necessário criar uma gramática em ?//, definir símbolos terminais e não terminais, e desenvolver o analisador léxico. Adicionalmente, é necessário o desenvolvimento do analisador sintático, com base nas regras da gramática e tendo em conta a análise léxica. O compilador da linguagem irá incorporar ambas as análises?// supramencionadas, e procederá a uma análise de ações semânticas e á geração do código. 
O código gerado será pseudo-código da maquina virtual VM, o analisador léxico será elaborado no Flex, e o Yacc será usado pora a ge//? do código e análises sintática e semântica.   


\section{Especificação dos requisitos}
\label{sec:especificacao:analise}
%Especificação dos requisitos (ver enunciado)

A LPIS definida deve permitir determinadas operaçãos necessárias ao bom funcionamento de uma linguagem imperativa, especificamente:

\begin{itemize}
\item declaração e manuseamento de variáveis atómicas do tipo inteiro que permitam a realização de operaçãoes aritméticas, relacionais e lógicas;
\item declararação e manuseamento variáveis estruturadas do tipo array de inteiros, com 1 ou 2 dimensões, que permitam apenas operações de indexação;
\item realização de instruções algorítmicas básicas como a atribuição de expressões a variáveis;
\item leitura do standard input e escrita no standard output;
\item realização de instruções de controlo do fluxo de execução que permitam aninhamento;
\end{itemize}

Opcionalmente, a linguagem definidad deve ser capaz de definir e invocar subprogramas sem parâmetros, mas que possam retornar um resultado atómico.

\newpage

\section{Dados}
\label{sec:dados:analise}

Uma linguagem imperativa completa necessita de permitir pelo menos três estruturas de controlo:

\begin{itemize}
\item IF()THEN\{\}ELSE\{\};
\item WHILE()\{\};
\item DO\{\}WHILE();
\end{itemize}

Por uma questão de simplificação do código, poderá adicionalmente permitir a estrutura IF()THEN\{\}.\\

De igual modo, permitindo a linguagem acesso a estruturas do tipo array, é necessário ter em conta que qualquer array, independentemente da dimensão, é representado em memória como um único array // uma dimensão. Contudo, é necessário establecer regras para o acesso a arrays uni e bidimensionais. Para garantir a eficácia da linguagem, considerar-se-á que o acesso será feito em "row major" para arrays bidimensionais.\\

Genericamente, o acesso a um array pode ser representado por a seguinte fórmula:\\

A[i] = b + w * (i - lb);\\

Sendo:

\begin{itemize}
\item b o endereço base;
\item w o tamanho do elemento;
\item i o índice do elemento;
\item lb o limite inferior na memória;
\end{itemize}

No caso do acesso em questão, w = 1 e lb = 0, logo:\\

A[i] = b + i;\\


Para um array bidimensional temos:\\

A[i][j] = b + w [(i - lr) + N(j - lc)];\\

Onde:

\begin{itemize}
\item b é o endereço base;
\item i é o índice da linha do elemento;
\item j é o índice da coluna do elemento;
\item w é o tamanho do elemento em bytes;
\item lr é o limite inferior da linha;
\item lc é o limite inferior da coluna;
\item N é o //?;
\end{itemize}

Assumindo w = 1 e lr = lc = 0, temos:\\

A[i][j] = b + i + N * j;\\


\section{Relações}
\label{sec:relacoes:analise}

Para o cálculo das expressões é necessário ter em conta algumas propriedades de cada tipo de expressão. Ou seja, é necessário verificar os tipos atómicos (variáveis, constantes, elementos de arrays), e os resultados das expressões  // inferência. Assim:\\

- Para as expressões aritméticas (soma, subtração, multiplicação, divisão, divisão inteira e módulo), bem como os elementos // da expressão, o tipo deverá ser um inteiro;

- Para as expressões relacionais (maior, menor, maior ou igual, menor ou igual, igual e diferente), os elementos da expressão deverão ser do tipo inteiro e o resulatdo um valor booleano;

- Para as expressões lógicas, os elementos deverão ser booleanos e o resultado deverá também ser booleano;

De notar que várias expressões podem ser compostas, pelo que ///. Adicionalmente, existe uma relação de precedência das operações, bem como de fatores. Um fator é uma expressão aninhada, um // ou uma variável. De igual modo /////.\\

Seguidamente temos os termos. Um termo é composto por operações multiplicativas entre fatores, sendo estas a multiplicação, a divisão inteira, e módulo. Posteriormente, poderá ser incluida a operação lógica "AND", por razões posteriormente explicitadas. As expressões seguintes na escala de prioridades são as expressões aditivas (soma, subtração, //). Poderá ser incluida a operação lógica "OR", por razões que tal como a inclusão de "AND", serão posteriormente explicitadas. As expressões de menor prioridade são as expressões relacionais (>, <, >=, <=, == e !=).\\

Para a execução do programa é necessário definir as instruções e operações que o definem. O programa pode efetuar cálculos utilizando as expressões previamente mencionadas. Note-se no entanto que subprogrmas podem ter ou não parâmetros, e devolver ou não um valor. Visto que a alocação de memória é efetuada numa stack virtual, é necessário, ///, criar uma frame no topo da stack com todas as variáveis locais declaradas, e parâmetros alocados em memória. Para distinguir o programa principal, a linguagem usa um sistema de níveis, em cada nível assume o valor 0 para o programa principal e o valor 1 para subprogramas. Finalmente, o início e fim de cada programa ou subprograma deve estar devidamente assinalado.  

   




 



