\chapter{Ferramenta \emph{pretty-printing} de um ficheiro \hologo{BibTeX}}
\label{chap:b2}

\section{Análise do Problema}
\label{sec:b2p:b2}
Nesta parte, o desafio é elaborar uma ferramenta de \emph{pretty-printing} que
indente corretamente cada campo, escreva um autor por linha e coloque sempre no
início os campos autor e título.

\section{Especificação dos requisitos}
\label{sec:spec:b2}

\subsection{Dados}

No \hologo{BibTeX}, cada tipo de entrada bibliográfica tem campos opcionais
e obrigatórios. Na resolução deste problema apenas se centrou nos obrigatórios,
dado que se quiser uma ferramenta genérica, que inclua outros pacotes, o número
de campos é elevado. De igual modo, os campos obrigatórios podem ser opcionais
para algum tipo de entrada, e vice---versa. Em extensões, como no
\textsc{Bib}\LaTeX{}, alguns campos são são comuns, por uma questão de compatibilidade.

Os campos considerados são:

\begin{itemize}


\item Organização
\item \emph{How Published}
\item Instituição
\item Publicação
\item Titulo do livro
\item Jornal
\item Edição
\item Capitulo
\item Morada
\item Volume
\item Serie
\item Escola
\item Numero
\item Editor
\item Autor
\item Titulo
\item Págs
\item Mês
\item Ano
\item Tipo

\end{itemize}

Note-se que estes campos podem ser tanto obrigatórios como opcionais.
A ordem com que os campos estão colocados não tem a obrigatoriedade de uma
sequência. Por exemplo o campo autor pode ser colocado no final da enumeração
dos campos, sem nenhum efeito colateral. O que decide a ordem dos elementos
é sempre o estilo de bibliografia.


\section{Desenho e implementação da solução}
\label{sec:des:b2}

A sugestão de solução apresentada, possui quatro \emph{START CONDITIONS}:
a \emph{SC} \texttt{ENTRY}, \emph{SC} \texttt{AUT}, a \emph{SC} \texttt{FIELD}
e, por último, a \emph{SPEC}. A necessidade de ter as primeiras \emph{SC}
deve-se à necessidade de criar um contexto para tratar os autores, bem como
o título, sendo estas ativadas dentro \emph{SC} \texttt{ENTRY}. O intuito \emph{SC}
\texttt{SPEC} já foi descrita em secções anteriores --- capturar par de
chavetas, para evitar conflitos com as outras \emph{ER's}.

Assim , passas-se a descrever a especificação de cada \emph{SC}.


\subsubsection{\emph{START CONDITION} \texttt{INITIAL}}

\begin{itemize}
\item 

\begin{verbatim}
\@[A-Za-z]+
\end{verbatim}

{pos = 2; BEGIN ENTRY;printf("\n\n\n################\n");}

\item 

\begin{verbatim}
[(.|\n)                            
\end{verbatim}
{;}



\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsubsection{\emph{START CONDITION} \texttt{ENTRY}}

\begin{itemize}
\item 

\begin{verbatim}
ENTRY>[}] 
\end{verbatim}
{print_campos(); BEGIN INITIAL;}
\item 

\begin{verbatim}
<ENTRY>[}][ ]*[,] {;} 
\end{verbatim}

\item 
\begin{verbatim}
<ENTRY>[Oo][Rr][Gg][Aa][Nn][Ii][Zz][Aa][Tt][Ii][Oo][Nn][ ]*"="[ ]*[{"]? 
\end{verbatim}
{i=0; fields[0][pos]=strdup("Organizacao----:\t");BEGIN FIELD;}

                        
                            

\item 
\begin{verbatim}
ENTRY>[Aa][Uu][Tt][Hh][Oo][Rr][ ]*"="[ ]*[{"] 
\end{verbatim}
{i=0; fields[0][0  ]=strdup("Autor(es) -----:\t");BEGIN AUT;}


\item 
\begin{verbatim}
<ENTRY>[Tt][Ii][Tt][Ll][Ee][ ]*"="[ ]*[{"] 
\end{verbatim}
 {i=0; fields[0][1  ]=strdup("Titulo --------:\t");BEGIN TITLE;}

\item 
\begin{verbatim}
(.|\n)
\end{verbatim}



\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{\emph{START CONDITION} \texttt{AUT}}

\begin{itemize}
\item 
\begin{verbatim}
[ \t]+"and"[ \t]+
\end{verbatim}
 {strcpy(value+i, "\n\t\t\t "); i+=5;}

\item 
\begin{verbatim}
<AUT>[}"][ ]*[ ]? 
\end{verbatim}
                                   strcpy(value+i,"\n"); i++; 
                                   fields[1][0]=strdup(value); 
				                   BEGIN ENTRY;}

\item 
\begin{verbatim}
(.|\n)
\end{verbatim}

{value[i++]=yytext[0];}


\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\emph{START CONDITION} \texttt{TITLE}}

\begin{itemize}
\item Captura dois ou mais espaços.
\begin{verbatim}
[ ]{2,}
\end{verbatim}

Apenas serve para consumir espaços a mais, imprimindo no \emph{stdout} um espaço.

\item Captura qualquer chaveta aberta, que não a do fim de campo.
\begin{verbatim}
[{]
\end{verbatim}

A ação desta captura é devido ao que foi exposto em capítulos anteriores. No entanto, como foi anteriormente explicado, vários contextos utilizam a \emph{START CONDTION} \texttt{SPEC}. Assim, como em anteriores \emph{START CONDTIONS} o valor do estado é guardado numa varrável global, com a macro \texttt{YYSTATE}. O chaveta é consumida.

\item Captura o final do campo caso seja aspas ou o fecho de chavetas.
\begin{verbatim}
[}"][ ]*[,]? 
\end{verbatim}

\item Captura tudo o resto.
\begin{verbatim}
(.)
\end{verbatim}
{value[i++]=yytext[0];}

\item Captura do caractere \emph{newline}
\begin{verbatim}
(\n)
\end{verbatim}

A ação é não fazer nada. Apenas serve para consumir eliminar quebras de linha no campo do título.


\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\emph{START CONDITION} \texttt{FIELD}}

\begin{itemize}
\item 
\begin{verbatim}
"\\url{"
\end{verbatim}
 { state_caller = YYSTATE; BEGIN SPEC;}

\item 
\begin{verbatim}
[ ]{2,}
\end{verbatim}

\item 
\begin{verbatim}
[{]
\end{verbatim}

\item 
\begin{verbatim}
[}"]?[ ]*[,]
\end{verbatim}
strcpy(value+i,"\n"); i++;
				                   fields[1][pos++]=strdup(value);
				                   BEGIN ENTRY;}

\item 
\begin{verbatim}
(.)
\end{verbatim}
 {value[i++]=yytext[0];}

\item 
\begin{verbatim}
(\n)
\end{verbatim}

\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{\emph{START CONDITION} \texttt{SPEC}}

\begin{itemize}
\item 

\begin{verbatim}
[}]
\end{verbatim}
yyless(0);BEGIN state_caller;

\item 
\begin{verbatim}
(.|\n)
\end{verbatim}
{value[i++]=yytext[0];}

\end{itemize}



\subsection{Estruturas de dados}

\subsection{Algoritmos}

\begin{verbatim}
void print_campos()
{
    int j;

    for(j = 0; j < pos; j++){
        printf("%s %s", fields[0][j], fields[1][j]);
    	free(fields[0][j]);
    	free(fields[1][j]);
    	fields[0][j]=NULL;
    	fields[1][j]=NULL;
    }

}
\end{verbatim}


\begin{verbatim}
int j;

    yylex();
 for(j = 0; j < MAX_ENTRIES; j++)
        {
            if(fields[0][j])
                free(fields[0][j]);
            else if (fields[1][j])
                free(fields[1][j]);

        }

\end{verbatim}

\section{Codificação e Testes}
\label{sec:ts:b2}

\subsection{Alternativas, Decisões e Problemas de Implementação}

\subsection{Testes e Resultados}
%Mostram-se a seguir alguns testes feitos (valores introduzidos) e
%%os respetivos resultados obtidos:
